/* Generated by GOB (v2.0.6) on Sun May 16 14:58:56 2004
   (do not edit directly) */

/* End world hunger, donate to the World Food Programme, http://www.wfp.org */

#define GOB_VERSION_MAJOR 2
#define GOB_VERSION_MINOR 0
#define GOB_VERSION_PATCHLEVEL 6

#define selfp (self->_priv)

#ifdef G_LIKELY
#define ___GOB_LIKELY(expr) G_LIKELY(expr)
#define ___GOB_UNLIKELY(expr) G_UNLIKELY(expr)
#else /* ! G_LIKELY */
#define ___GOB_LIKELY(expr) (expr)
#define ___GOB_UNLIKELY(expr) (expr)
#endif /* G_LIKELY */

#line 3 "gpeiconlist.gob"

/*
  gpeiconlist - an icon list widget
  Copyright (C) 2002  Robert Mibus <mibus@handhelds.org>

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <gtk/gtk.h>

#include "gpe-iconlist.h"
#include "gpeiconlistview.h"

#line 50 "gpe-iconlist.c"
/* self casting macros */
#define SELF(x) GPE_ICONLIST(x)
#define SELF_CONST(x) GPE_ICONLIST_CONST(x)
#define IS_SELF(x) GPE_IS_ICONLIST(x)
#define TYPE_SELF GPE_TYPE_ICONLIST
#define SELF_CLASS(x) GPE_ICONLIST_CLASS(x)

#define SELF_GET_CLASS(x) GPE_ICONLIST_GET_CLASS(x)

/* self typedefs */
typedef GPEIconList Self;
typedef GPEIconListClass SelfClass;

struct _GPEIconListPrivate {
#line 33 "gpeiconlist.gob"
	GtkWidget * view;
#line 67 "gpe-iconlist.c"
};
/* here are local prototypes */
static void gpe_iconlist_class_init (GPEIconListClass * c) G_GNUC_UNUSED;
static void gpe_iconlist__relay_show_popup (GtkWidget * w, gpointer udata, gpointer self) G_GNUC_UNUSED;
static void gpe_iconlist__relay_clicked (GtkWidget * w, gpointer udata, gpointer self) G_GNUC_UNUSED;
static void gpe_iconlist_init (GPEIconList * self) G_GNUC_UNUSED;

/*
 * Signal connection wrapper macro shortcuts
 */
#define self_connect__clicked(object,func,data)	gpe_iconlist_connect__clicked((object),(func),(data))
#define self_connect_after__clicked(object,func,data)	gpe_iconlist_connect_after__clicked((object),(func),(data))
#define self_connect_data__clicked(object,func,data,destroy_data,flags)	gpe_iconlist_connect_data__clicked((object),(func),(data),(destroy_data),(flags))
#define self_connect__show_popup(object,func,data)	gpe_iconlist_connect__show_popup((object),(func),(data))
#define self_connect_after__show_popup(object,func,data)	gpe_iconlist_connect_after__show_popup((object),(func),(data))
#define self_connect_data__show_popup(object,func,data,destroy_data,flags)	gpe_iconlist_connect_data__show_popup((object),(func),(data),(destroy_data),(flags))

typedef void  (*___Sig1) (GPEIconList *, gpointer , gpointer);

static void
___marshal_Sig1 (GClosure *closure,
	GValue *return_value,
	guint n_param_values,
	const GValue *param_values,
	gpointer invocation_hint,
	gpointer marshal_data)
{
	register ___Sig1 callback;
	register GCClosure *cc = (GCClosure*) closure;
	register gpointer data1, data2;

	g_return_if_fail (n_param_values == 2);

	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = g_value_peek_pointer (param_values + 0);
	} else {
		data1 = g_value_peek_pointer (param_values + 0);
		data2 = closure->data;
	}

	callback = (___Sig1) (marshal_data != NULL ? marshal_data : cc->callback);

	callback ((GPEIconList *)data1,
		(gpointer ) g_value_get_pointer (param_values + 1),
		data2);
}


enum {
	CLICKED_SIGNAL,
	SHOW_POPUP_SIGNAL,
	LAST_SIGNAL
};

static guint object_signals[LAST_SIGNAL] = {0};

/* pointer to the class of our parent */
static GtkScrolledWindowClass *parent_class = NULL;

/* Short form macros */
#if defined(__GNUC__) && !defined(__STRICT_ANSI__)
#define self_clicked(args...) gpe_iconlist_clicked(args)
#define self_show_popup(args...) gpe_iconlist_show_popup(args)
#define self__relay_show_popup(args...) gpe_iconlist__relay_show_popup(args)
#define self__relay_clicked(args...) gpe_iconlist__relay_clicked(args)
#define self_new() gpe_iconlist_new()
#define self_set_bg(args...) gpe_iconlist_set_bg(args)
#define self_set_bg_pixmap(args...) gpe_iconlist_set_bg_pixmap(args)
#define self_set_bg_color(args...) gpe_iconlist_set_bg_color(args)
#define self_add_item(args...) gpe_iconlist_add_item(args)
#define self_add_item_pixbuf(args...) gpe_iconlist_add_item_pixbuf(args)
#define self_remove_item(args...) gpe_iconlist_remove_item(args)
#define self_set_embolden(args...) gpe_iconlist_set_embolden(args)
#define self_set_show_title(args...) gpe_iconlist_set_show_title(args)
#define self_set_icon_xmargin(args...) gpe_iconlist_set_icon_xmargin(args)
#define self_clear(args...) gpe_iconlist_clear(args)
#define self_set_icon_size(args...) gpe_iconlist_set_icon_size(args)
#define self_popup_removed(args...) gpe_iconlist_popup_removed(args)
#endif /* __GNUC__ && !__STRICT_ANSI__ */

/* Short form pointers */
static void (* const self_clicked) (GPEIconList * self, gpointer udata) = gpe_iconlist_clicked;
static void (* const self_show_popup) (GPEIconList * self, gpointer udata) = gpe_iconlist_show_popup;
static void (* const self__relay_show_popup) (GtkWidget * w, gpointer udata, gpointer self) = gpe_iconlist__relay_show_popup;
static void (* const self__relay_clicked) (GtkWidget * w, gpointer udata, gpointer self) = gpe_iconlist__relay_clicked;
static GtkWidget * (* const self_new) (void) = gpe_iconlist_new;
static void (* const self_set_bg) (GPEIconList * self, char * bg) = gpe_iconlist_set_bg;
static void (* const self_set_bg_pixmap) (GPEIconList * self, GdkPixbuf * bg) = gpe_iconlist_set_bg_pixmap;
static void (* const self_set_bg_color) (GPEIconList * self, guint32 color) = gpe_iconlist_set_bg_color;
static GObject * (* const self_add_item) (GPEIconList * self, char * title, char * icon, gpointer udata) = gpe_iconlist_add_item;
static GObject * (* const self_add_item_pixbuf) (GPEIconList * self, char * title, GdkPixbuf * icon, gpointer udata) = gpe_iconlist_add_item_pixbuf;
static void (* const self_remove_item) (GPEIconList * self, GObject * item) = gpe_iconlist_remove_item;
static void (* const self_set_embolden) (GPEIconList * self, gboolean yes) = gpe_iconlist_set_embolden;
static void (* const self_set_show_title) (GPEIconList * self, gboolean yes) = gpe_iconlist_set_show_title;
static void (* const self_set_icon_xmargin) (GPEIconList * self, guint margin) = gpe_iconlist_set_icon_xmargin;
static void (* const self_clear) (GPEIconList * self) = gpe_iconlist_clear;
static void (* const self_set_icon_size) (GPEIconList * self, guint size) = gpe_iconlist_set_icon_size;
static void (* const self_popup_removed) (GPEIconList * self) = gpe_iconlist_popup_removed;

GType
gpe_iconlist_get_type (void)
{
	static GType type = 0;

	if ___GOB_UNLIKELY(type == 0) {
		static const GTypeInfo info = {
			sizeof (GPEIconListClass),
			(GBaseInitFunc) NULL,
			(GBaseFinalizeFunc) NULL,
			(GClassInitFunc) gpe_iconlist_class_init,
			(GClassFinalizeFunc) NULL,
			NULL /* class_data */,
			sizeof (GPEIconList),
			0 /* n_preallocs */,
			(GInstanceInitFunc) gpe_iconlist_init,
		};

		type = g_type_register_static (GTK_TYPE_SCROLLED_WINDOW, "GPEIconList", &info, (GTypeFlags)0);
	}

	return type;
}

/* a macro for creating a new object of our type */
#define GET_NEW ((GPEIconList *)g_object_new(gpe_iconlist_get_type(), NULL))

/* a function for creating a new object of our type */
#include <stdarg.h>
static GPEIconList * GET_NEW_VARG (const char *first, ...) G_GNUC_UNUSED;
static GPEIconList *
GET_NEW_VARG (const char *first, ...)
{
	GPEIconList *ret;
	va_list ap;
	va_start (ap, first);
	ret = (GPEIconList *)g_object_new_valist (gpe_iconlist_get_type (), first, ap);
	va_end (ap);
	return ret;
}


static void
___finalize(GObject *obj_self)
{
#define __GOB_FUNCTION__ "GPE:IconList::finalize"
	GPEIconList *self = GPE_ICONLIST (obj_self);
	gpointer priv = self->_priv;
	if(G_OBJECT_CLASS(parent_class)->finalize) \
		(* G_OBJECT_CLASS(parent_class)->finalize)(obj_self);
	g_free (priv);
	return;
	self = NULL;
}
#undef __GOB_FUNCTION__

static void 
gpe_iconlist_class_init (GPEIconListClass * c)
{
#define __GOB_FUNCTION__ "GPE:IconList::class_init"
	GObjectClass *g_object_class = (GObjectClass*) c;

	parent_class = g_type_class_ref (GTK_TYPE_SCROLLED_WINDOW);

	object_signals[CLICKED_SIGNAL] =
		g_signal_new ("clicked",
			G_TYPE_FROM_CLASS (g_object_class),
			(GSignalFlags)(G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION),
			G_STRUCT_OFFSET (GPEIconListClass, clicked),
			NULL, NULL,
			___marshal_Sig1,
			G_TYPE_NONE, 1,
			G_TYPE_POINTER);
	if ___GOB_UNLIKELY(sizeof(gpointer ) != sizeof(gpointer )) {
		g_error("gpeiconlist.gob line 36: Type mismatch of \"clicked\" signal signature");
	}
	object_signals[SHOW_POPUP_SIGNAL] =
		g_signal_new ("show_popup",
			G_TYPE_FROM_CLASS (g_object_class),
			(GSignalFlags)(G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION),
			G_STRUCT_OFFSET (GPEIconListClass, show_popup),
			NULL, NULL,
			___marshal_Sig1,
			G_TYPE_NONE, 1,
			G_TYPE_POINTER);
	if ___GOB_UNLIKELY(sizeof(gpointer ) != sizeof(gpointer )) {
		g_error("gpeiconlist.gob line 39: Type mismatch of \"show_popup\" signal signature");
	}

	c->clicked = NULL;
	c->show_popup = NULL;
	g_object_class->finalize = ___finalize;
	return;
	c = NULL;
	g_object_class = NULL;
}
#undef __GOB_FUNCTION__
#line 55 "gpeiconlist.gob"
static void 
gpe_iconlist_init (GPEIconList * self)
#line 268 "gpe-iconlist.c"
{
#define __GOB_FUNCTION__ "GPE:IconList::init"
	self->_priv = g_new0 (GPEIconListPrivate, 1);
 {
#line 56 "gpeiconlist.gob"

	  GtkWidget *vp;

	  gtk_scrolled_window_set_hadjustment (GTK_SCROLLED_WINDOW(self), NULL);
	  gtk_scrolled_window_set_vadjustment (GTK_SCROLLED_WINDOW(self), NULL);

	  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (GTK_SCROLLED_WINDOW (self)),
					  GTK_POLICY_NEVER, GTK_POLICY_ALWAYS);

	  vp = gtk_viewport_new (NULL, NULL);
	  gtk_container_add (GTK_CONTAINER (self), vp);

	  self->_priv->view = gpe_icon_list_view_new ();
	  gtk_container_add (GTK_CONTAINER (vp), self->_priv->view);

	  g_signal_connect (G_OBJECT (self->_priv->view), "clicked", G_CALLBACK (gpe_iconlist__relay_clicked), self);
	  g_signal_connect (G_OBJECT (self->_priv->view), "show_popup", G_CALLBACK (gpe_iconlist__relay_show_popup), self); 

	  gtk_widget_show_all (vp);
	
#line 294 "gpe-iconlist.c"
 }
	return;
	self = NULL;
}
#undef __GOB_FUNCTION__


#line 36 "gpeiconlist.gob"
void 
gpe_iconlist_clicked (GPEIconList * self, gpointer udata)
#line 305 "gpe-iconlist.c"
{
	GValue ___param_values[2];
	GValue ___return_val = {0};

#line 36 "gpeiconlist.gob"
	g_return_if_fail (self != NULL);
#line 36 "gpeiconlist.gob"
	g_return_if_fail (GPE_IS_ICONLIST (self));
#line 314 "gpe-iconlist.c"

	___param_values[0].g_type = 0;
	g_value_init (&___param_values[0], G_TYPE_FROM_INSTANCE (self));
	g_value_set_instance (&___param_values[0], (gpointer) self);

	___param_values[1].g_type = 0;
	g_value_init (&___param_values[1], G_TYPE_POINTER);
	g_value_set_pointer (&___param_values[1], (gpointer ) udata);

	g_signal_emitv (___param_values,
		object_signals[CLICKED_SIGNAL],
		0 /* detail */,
		&___return_val);

	g_value_unset (&___param_values[0]);
	g_value_unset (&___param_values[1]);
}

#line 39 "gpeiconlist.gob"
void 
gpe_iconlist_show_popup (GPEIconList * self, gpointer udata)
#line 336 "gpe-iconlist.c"
{
	GValue ___param_values[2];
	GValue ___return_val = {0};

#line 39 "gpeiconlist.gob"
	g_return_if_fail (self != NULL);
#line 39 "gpeiconlist.gob"
	g_return_if_fail (GPE_IS_ICONLIST (self));
#line 345 "gpe-iconlist.c"

	___param_values[0].g_type = 0;
	g_value_init (&___param_values[0], G_TYPE_FROM_INSTANCE (self));
	g_value_set_instance (&___param_values[0], (gpointer) self);

	___param_values[1].g_type = 0;
	g_value_init (&___param_values[1], G_TYPE_POINTER);
	g_value_set_pointer (&___param_values[1], (gpointer ) udata);

	g_signal_emitv (___param_values,
		object_signals[SHOW_POPUP_SIGNAL],
		0 /* detail */,
		&___return_val);

	g_value_unset (&___param_values[0]);
	g_value_unset (&___param_values[1]);
}

#line 42 "gpeiconlist.gob"
static void 
gpe_iconlist__relay_show_popup (GtkWidget * w, gpointer udata, gpointer self)
#line 367 "gpe-iconlist.c"
{
#define __GOB_FUNCTION__ "GPE:IconList::_relay_show_popup"
{
#line 44 "gpeiconlist.gob"
	
	  gpe_iconlist_show_popup (self, udata);
	}}
#line 375 "gpe-iconlist.c"
#undef __GOB_FUNCTION__

#line 48 "gpeiconlist.gob"
static void 
gpe_iconlist__relay_clicked (GtkWidget * w, gpointer udata, gpointer self)
#line 381 "gpe-iconlist.c"
{
#define __GOB_FUNCTION__ "GPE:IconList::_relay_clicked"
{
#line 50 "gpeiconlist.gob"
	
	  gpe_iconlist_clicked (self, udata);
	}}
#line 389 "gpe-iconlist.c"
#undef __GOB_FUNCTION__


#line 77 "gpeiconlist.gob"
GtkWidget * 
gpe_iconlist_new (void)
#line 396 "gpe-iconlist.c"
{
#define __GOB_FUNCTION__ "GPE:IconList::new"
{
#line 79 "gpeiconlist.gob"
	
	  return GTK_WIDGET (GET_NEW);
	}}
#line 404 "gpe-iconlist.c"
#undef __GOB_FUNCTION__

#line 84 "gpeiconlist.gob"
void 
gpe_iconlist_set_bg (GPEIconList * self, char * bg)
#line 410 "gpe-iconlist.c"
{
#define __GOB_FUNCTION__ "GPE:IconList::set_bg"
{
#line 85 "gpeiconlist.gob"
	
	  gpe_icon_list_view_set_bg (GPE_ICON_LIST_VIEW (self->_priv->view), bg);
	}}
#line 418 "gpe-iconlist.c"
#undef __GOB_FUNCTION__

#line 89 "gpeiconlist.gob"
void 
gpe_iconlist_set_bg_pixmap (GPEIconList * self, GdkPixbuf * bg)
#line 424 "gpe-iconlist.c"
{
#define __GOB_FUNCTION__ "GPE:IconList::set_bg_pixmap"
{
#line 90 "gpeiconlist.gob"
	
	  gpe_icon_list_view_set_bg_pixmap (GPE_ICON_LIST_VIEW (self->_priv->view), bg);
	}}
#line 432 "gpe-iconlist.c"
#undef __GOB_FUNCTION__

#line 94 "gpeiconlist.gob"
void 
gpe_iconlist_set_bg_color (GPEIconList * self, guint32 color)
#line 438 "gpe-iconlist.c"
{
#define __GOB_FUNCTION__ "GPE:IconList::set_bg_color"
{
#line 95 "gpeiconlist.gob"
	
	  gpe_icon_list_view_set_bg_color (GPE_ICON_LIST_VIEW (self->_priv->view), color);
	}}
#line 446 "gpe-iconlist.c"
#undef __GOB_FUNCTION__

#line 99 "gpeiconlist.gob"
GObject * 
gpe_iconlist_add_item (GPEIconList * self, char * title, char * icon, gpointer udata)
#line 452 "gpe-iconlist.c"
{
#define __GOB_FUNCTION__ "GPE:IconList::add_item"
#line 99 "gpeiconlist.gob"
	g_return_val_if_fail (self != NULL, (GObject * )0);
#line 99 "gpeiconlist.gob"
	g_return_val_if_fail (GPE_IS_ICONLIST (self), (GObject * )0);
#line 459 "gpe-iconlist.c"
{
#line 100 "gpeiconlist.gob"
	
	  return gpe_icon_list_view_add_item (GPE_ICON_LIST_VIEW (self->_priv->view),
					      title, icon, udata);
	}}
#line 466 "gpe-iconlist.c"
#undef __GOB_FUNCTION__

#line 105 "gpeiconlist.gob"
GObject * 
gpe_iconlist_add_item_pixbuf (GPEIconList * self, char * title, GdkPixbuf * icon, gpointer udata)
#line 472 "gpe-iconlist.c"
{
#define __GOB_FUNCTION__ "GPE:IconList::add_item_pixbuf"
#line 105 "gpeiconlist.gob"
	g_return_val_if_fail (self != NULL, (GObject * )0);
#line 105 "gpeiconlist.gob"
	g_return_val_if_fail (GPE_IS_ICONLIST (self), (GObject * )0);
#line 479 "gpe-iconlist.c"
{
#line 106 "gpeiconlist.gob"
	
	  return gpe_icon_list_view_add_item_pixbuf (GPE_ICON_LIST_VIEW (self->_priv->view),
					             title, icon, udata);
	}}
#line 486 "gpe-iconlist.c"
#undef __GOB_FUNCTION__

#line 111 "gpeiconlist.gob"
void 
gpe_iconlist_remove_item (GPEIconList * self, GObject * item)
#line 492 "gpe-iconlist.c"
{
#define __GOB_FUNCTION__ "GPE:IconList::remove_item"
#line 111 "gpeiconlist.gob"
	g_return_if_fail (self != NULL);
#line 111 "gpeiconlist.gob"
	g_return_if_fail (GPE_IS_ICONLIST (self));
#line 499 "gpe-iconlist.c"
{
#line 112 "gpeiconlist.gob"
	
	  gpe_icon_list_view_remove_item (GPE_ICON_LIST_VIEW (self->_priv->view), item);
	}}
#line 505 "gpe-iconlist.c"
#undef __GOB_FUNCTION__

#line 116 "gpeiconlist.gob"
void 
gpe_iconlist_set_embolden (GPEIconList * self, gboolean yes)
#line 511 "gpe-iconlist.c"
{
#define __GOB_FUNCTION__ "GPE:IconList::set_embolden"
#line 116 "gpeiconlist.gob"
	g_return_if_fail (self != NULL);
#line 116 "gpeiconlist.gob"
	g_return_if_fail (GPE_IS_ICONLIST (self));
#line 518 "gpe-iconlist.c"
{
#line 117 "gpeiconlist.gob"
	
	  gpe_icon_list_view_set_embolden (GPE_ICON_LIST_VIEW (self->_priv->view), yes);
	}}
#line 524 "gpe-iconlist.c"
#undef __GOB_FUNCTION__

#line 121 "gpeiconlist.gob"
void 
gpe_iconlist_set_show_title (GPEIconList * self, gboolean yes)
#line 530 "gpe-iconlist.c"
{
#define __GOB_FUNCTION__ "GPE:IconList::set_show_title"
#line 121 "gpeiconlist.gob"
	g_return_if_fail (self != NULL);
#line 121 "gpeiconlist.gob"
	g_return_if_fail (GPE_IS_ICONLIST (self));
#line 537 "gpe-iconlist.c"
{
#line 122 "gpeiconlist.gob"
	
	  gpe_icon_list_view_set_show_title (GPE_ICON_LIST_VIEW (self->_priv->view), yes);
	}}
#line 543 "gpe-iconlist.c"
#undef __GOB_FUNCTION__

#line 126 "gpeiconlist.gob"
void 
gpe_iconlist_set_icon_xmargin (GPEIconList * self, guint margin)
#line 549 "gpe-iconlist.c"
{
#define __GOB_FUNCTION__ "GPE:IconList::set_icon_xmargin"
#line 126 "gpeiconlist.gob"
	g_return_if_fail (self != NULL);
#line 126 "gpeiconlist.gob"
	g_return_if_fail (GPE_IS_ICONLIST (self));
#line 556 "gpe-iconlist.c"
{
#line 127 "gpeiconlist.gob"
	
	  gpe_icon_list_view_set_icon_xmargin (GPE_ICON_LIST_VIEW (self->_priv->view), margin);
	}}
#line 562 "gpe-iconlist.c"
#undef __GOB_FUNCTION__

#line 131 "gpeiconlist.gob"
void 
gpe_iconlist_clear (GPEIconList * self)
#line 568 "gpe-iconlist.c"
{
#define __GOB_FUNCTION__ "GPE:IconList::clear"
#line 131 "gpeiconlist.gob"
	g_return_if_fail (self != NULL);
#line 131 "gpeiconlist.gob"
	g_return_if_fail (GPE_IS_ICONLIST (self));
#line 575 "gpe-iconlist.c"
{
#line 132 "gpeiconlist.gob"
	
	  gpe_icon_list_view_clear (GPE_ICON_LIST_VIEW (self->_priv->view));
	}}
#line 581 "gpe-iconlist.c"
#undef __GOB_FUNCTION__

#line 136 "gpeiconlist.gob"
void 
gpe_iconlist_set_icon_size (GPEIconList * self, guint size)
#line 587 "gpe-iconlist.c"
{
#define __GOB_FUNCTION__ "GPE:IconList::set_icon_size"
#line 136 "gpeiconlist.gob"
	g_return_if_fail (self != NULL);
#line 136 "gpeiconlist.gob"
	g_return_if_fail (GPE_IS_ICONLIST (self));
#line 594 "gpe-iconlist.c"
{
#line 137 "gpeiconlist.gob"
	
	  gpe_icon_list_view_set_icon_size (GPE_ICON_LIST_VIEW (self->_priv->view), size);
	}}
#line 600 "gpe-iconlist.c"
#undef __GOB_FUNCTION__

#line 141 "gpeiconlist.gob"
void 
gpe_iconlist_popup_removed (GPEIconList * self)
#line 606 "gpe-iconlist.c"
{
#define __GOB_FUNCTION__ "GPE:IconList::popup_removed"
#line 141 "gpeiconlist.gob"
	g_return_if_fail (self != NULL);
#line 141 "gpeiconlist.gob"
	g_return_if_fail (GPE_IS_ICONLIST (self));
#line 613 "gpe-iconlist.c"
{
#line 142 "gpeiconlist.gob"
	
	  gpe_icon_list_view_popup_removed (GPE_ICON_LIST_VIEW (self->_priv->view));
	}}
#line 619 "gpe-iconlist.c"
#undef __GOB_FUNCTION__


#if (!defined __GNUC__) || (defined __GNUC__ && defined __STRICT_ANSI__)
/*REALLY BAD HACK
  This is to avoid unused warnings if you don't call
  some method.  I need to find a better way to do
  this, not needed in GCC since we use some gcc
  extentions to make saner, faster code */
static void
___gpe_iconlist_really_bad_hack_to_avoid_warnings(void)
{
	((void (*)(void))GET_NEW_VARG)();
	((void (*)(void))self_clicked)();
	((void (*)(void))self_show_popup)();
	((void (*)(void))self__relay_show_popup)();
	((void (*)(void))self__relay_clicked)();
	((void (*)(void))self_new)();
	((void (*)(void))self_set_bg)();
	((void (*)(void))self_set_bg_pixmap)();
	((void (*)(void))self_set_bg_color)();
	((void (*)(void))self_add_item)();
	((void (*)(void))self_add_item_pixbuf)();
	((void (*)(void))self_remove_item)();
	((void (*)(void))self_set_embolden)();
	((void (*)(void))self_set_show_title)();
	((void (*)(void))self_set_icon_xmargin)();
	((void (*)(void))self_clear)();
	((void (*)(void))self_set_icon_size)();
	((void (*)(void))self_popup_removed)();
	___gpe_iconlist_really_bad_hack_to_avoid_warnings();
}
#endif /* !__GNUC__ || (__GNUC__ && __STRICT_ANSI__) */

